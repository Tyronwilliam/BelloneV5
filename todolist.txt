Task Dialog
- Function duplicate Task  
- Function Timer  (Context)
- TextArea ( Commentaire)
- Etiquette/Labels

Kanban 

- Faire les requetes changement de columns ordre = OK
- Same pour changement de task entre columns et ordre entre tasks =OK 
- Faire function change titre des tache et columns 
- Extract la logique dans un hook poutr reduire la taille du composant 
- Refactor les props des composants enfants pour y voir plus clair 
- Revoir les functions d'Update de l'UI pour rendre l'animation plus fluide 
- Revoir le handleDragMove  


// Handle Drag Move
  // const handleDragMove = async (event: DragMoveEvent) => {
  //   const { active, over } = event;
  //   if (!over) return;
  //   if (
  //     active.id.toString().includes("item") &&
  //     over.id.toString().includes("item") &&
  //     active.id !== over.id
  //   ) {
  //     const activeContainer = findValueOfItems(active.id, "item");
  //     const overContainer = findValueOfItems(over.id, "item");
  //     if (!activeContainer || !overContainer) return;

  //     const activeContainerIndex = containers.findIndex(
  //       (container) =>
  //         String(container.pseudo_id) === String(activeContainer.pseudo_id)
  //     );
  //     const overContainerIndex = containers.findIndex((container) => {
  //       return String(container.pseudo_id) === String(overContainer.pseudo_id);
  //     });

  //     const activeItemIndex = activeContainer.items.findIndex(
  //       (item) => item.pseudo_id === active.id
  //     );
  //     const overItemIndex = overContainer.items.findIndex(
  //       (item) => item.pseudo_id === over.id
  //     );

  //     if (activeContainerIndex === overContainerIndex) {
  //       // Within the same container
  //       const newItems = [...containers];

  //       newItems[activeContainerIndex].items = arrayMove(
  //         newItems[activeContainerIndex].items,
  //         activeItemIndex,
  //         overItemIndex
  //       );
  //       setContainers(newItems);
  //     } else {
  //       // Between different containers
  //       const newItems = [...containers];
  //       const [removedItem] = newItems[activeContainerIndex].items.splice(
  //         activeItemIndex,
  //         1
  //       );
  //       newItems[overContainerIndex].items.splice(
  //         overItemIndex,
  //         0,
  //         removedItem
  //       );

  //       setContainers(newItems);
  //     }
  //   }
  // };

  // Handle Drag End
  // const handleDragEnd = async (event: DragEndEvent) => {
  //   const { active, over } = event;
  //   if (!over) return;

  //   if (
  //     active.id.toString().includes("container") &&
  //     over.id.toString().includes("container") &&
  //     active.id !== over.id
  //   ) {
  //     console.log("CONTAINER & CONTAINER");

  //     const activeContainerIndex = containers.findIndex(
  //       (container) => container.pseudo_id === active.id
  //     );
  //     const overContainerIndex = containers.findIndex(
  //       (container) => container.pseudo_id === over.id
  //     );

  //     if (activeContainerIndex !== overContainerIndex) {
  //       const newItems = arrayMove(
  //         containers,
  //         activeContainerIndex,
  //         overContainerIndex
  //       );
  //       await Promise.all(
  //         newItems.map(async (container, index) => {
  //           handleUpdateColumns({
  //             id: container.id as unknown as string,
  //             order: index, // The new order for the container
  //           });
  //         })
  //       );
  //       const columnsWithTasks = await getColumnsWithTasks(projectId);
  //       setContainers(columnsWithTasks);
  //     }
  //   } else if (
  //     active.id.toString().includes("item") &&
  //     over.id.toString().includes("container")
  //   ) {
  //     console.log("ITEM & CONTAINER");
  //     console.log("FRERE");

  //     const activeContainer = findValueOfItems(active.id, "item");
  //     const overContainer = findValueOfItems(over.id, "container");

  //     if (!activeContainer || !overContainer) return;

  //     const activeContainerIndex = containers.findIndex(
  //       (container) => container.pseudo_id === activeContainer.pseudo_id
  //     );
  //     const overContainerIndex = containers.findIndex(
  //       (container) => container.pseudo_id === overContainer.pseudo_id
  //     );

  //     const activeItemIndex = activeContainer.items.findIndex(
  //       (item) => item.pseudo_id === active.id
  //     );
  //     const newItems = [...containers];
  //     const [removedItem] = newItems[activeContainerIndex].items.splice(
  //       activeItemIndex,
  //       1
  //     );
  //     newItems[overContainerIndex].items.push(removedItem);
  //     // After updating the UI, update the backend

  //     // Update the task's column_id and order in the target container
  //     await handleUpdateTask({
  //       id: removedItem.id,
  //       column_id: newItems[overContainerIndex].id as string,
  //       order: newItems[overContainerIndex].items.length - 1, // Place it at the end of the new container's list
  //     });

  //     // Optionally update the tasks order in the source container if necessary
  //     newItems[activeContainerIndex].items.forEach(async (item, index) => {
  //       if (item.order !== index) {
  //         await handleUpdateTask({
  //           id: item.id,
  //           column_id: newItems[activeContainerIndex].id as string,
  //           order: index,
  //         });
  //       }
  //     });

  //     // Optionally update the tasks order in the target container after the move
  //     newItems[overContainerIndex].items.forEach(async (item, index) => {
  //       if (item.order !== index) {
  //         await handleUpdateTask({
  //           id: item.id,
  //           column_id: newItems[overContainerIndex].id as string,
  //           order: index,
  //         });
  //       }
  //     });

  //     // Fetch the updated columns and tasks from the backend
  //     const columnsWithTasks = await getColumnsWithTasks(projectId);
  //     setContainers(columnsWithTasks);
  //   }
  //   /////////////////////////////////////////////////////////////////////////////////////
  //   if (
  //     active.id.toString().includes("item") &&
  //     over.id.toString().includes("item") &&
  //     active.id !== over.id
  //   ) {
  //     console.log("ITEM & ITEM ");
  //     const activeContainer = findValueOfItems(active.id, "item");
  //     const overContainer = findValueOfItems(over.id, "item");
  //     if (!activeContainer || !overContainer) return;

  //     const activeContainerIndex = containers.findIndex(
  //       (container) =>
  //         String(container.pseudo_id) === String(activeContainer.pseudo_id)
  //     );
  //     const overContainerIndex = containers.findIndex((container) => {
  //       return String(container.pseudo_id) === String(overContainer.pseudo_id);
  //     });

  //     const activeItemIndex = activeContainer.items.findIndex(
  //       (item) => item.pseudo_id === active.id
  //     );
  //     const overItemIndex = overContainer.items.findIndex(
  //       (item) => item.pseudo_id === over.id
  //     );

  //     if (activeContainerIndex === overContainerIndex) {
  //       // Within the same container
  //       const newItems = [...containers];

  //       newItems[activeContainerIndex].items = arrayMove(
  //         newItems[activeContainerIndex].items,
  //         activeItemIndex,
  //         overItemIndex
  //       );

  //       // Update orders in the backend
  //       await Promise.all(
  //         newItems[activeContainerIndex].items.map(async (item, index) => {
  //           if (item.order !== index) {
  //             console.log(item.order, index); // Log the old and new orders
  //             await handleUpdateTask({
  //               id: item.id,
  //               column_id: newItems[activeContainerIndex].id as string,
  //               order: index,
  //             });
  //           }
  //         })
  //       );

  //       setContainers(newItems);
  //     } else {
  //       console.log("BETWEEN CONTAINER");
  //       // Between different containers
  //       const newItems = [...containers];
  //       const [removedItem] = newItems[activeContainerIndex].items.splice(
  //         activeItemIndex,
  //         1
  //       );
  //       newItems[overContainerIndex].items.splice(
  //         overItemIndex,
  //         0,
  //         removedItem
  //       );

  //       // Update the moved task in the backend
  //       // Update orders for the source container
  //       newItems[activeContainerIndex].items.forEach((item, index) => {
  //         // Vérifie si l'ordre a changé avant d'envoyer la requête
  //         if (item.order !== index) {
  //           handleUpdateTask({
  //             id: item.id,
  //             column_id: newItems[activeContainerIndex].id as string,
  //             order: index,
  //           });
  //         }
  //       });

  //       // Update orders for the target container
  //       newItems[overContainerIndex].items.forEach((item, index) => {
  //         // Vérifie si l'ordre a changé avant d'envoyer la requête
  //         if (item.order !== index) {
  //           handleUpdateTask({
  //             id: item.id,
  //             column_id: newItems[overContainerIndex].id as string,
  //             order: index,
  //           });
  //         }
  //       });

  //       // Vérifie si la tâche déplacée a réellement changé de colonne ou d'ordre
  //       if (
  //         removedItem.column_id !== newItems[overContainerIndex].id ||
  //         removedItem.order !== overItemIndex
  //       ) {
  //         handleUpdateTask({
  //           id: removedItem.id,
  //           column_id: newItems[overContainerIndex].id as string,
  //           order: overItemIndex,
  //         });
  //       }
  //       setContainers(newItems);
  //     }
  //   }

  //   setActiveId(null);
  // };